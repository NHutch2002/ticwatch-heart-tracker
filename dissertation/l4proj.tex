% REMEMBER: You must not plagiarise anything in your report. Be extremely careful.

\documentclass{l4proj}

    
%
% put any additional packages here
%

\begin{document}

%==============================================================================
%% METADATA
\title{Heart Rate Recovery Tracking for Fitness on a Smartwatch}
\author{Nathan Hutchison}
\date{February 2, 2024}

\maketitle

%==============================================================================
%% ABSTRACT
\begin{abstract}
    Every abstract follows a similar pattern. Motivate; set aims; describe work; explain results.
    \vskip 0.5em
    ``XYZ is bad. This project investigated ABC to determine if it was better. 
    ABC used XXX and YYY to implement ZZZ. This is particularly interesting as XXX and YYY have
    never been used together. It was found that  
    ABC was 20\% better than XYZ, though it caused rabies in half of subjects.''
\end{abstract}

%==============================================================================

% EDUCATION REUSE CONSENT FORM
% If you consent to your project being shown to future students for educational purposes
% then insert your name and the date below to  sign the education use form that appears in the front of the document. 
% You must explicitly give consent if you wish to do so.
% If you sign, your project may be included in the Hall of Fame if it scores particularly highly.
%
% Please note that you are under no obligation to sign 
% this declaration, but doing so would help future students.
%
\def\consentname {Nathan Hutchison} % your full name
\def\consentdate {05 February 2024} % the date you agree
%
\educationalconsent


%==============================================================================
\tableofcontents

%==============================================================================
%% Notes on formatting
%==============================================================================
% The first page, abstract and table of contents are numbered using Roman numerals and are not
% included in the page count. 
%
% From now on pages are numbered
% using Arabic numerals. Therefore, immediately after the first call to \chapter we need the call
% \pagenumbering{arabic} and this should be called once only in the document. 
%
% Do not alter the bibliography style.
%
% The first Chapter should then be on page 1. You are allowed 40 pages for a 40 credit project and 30 pages for a 
% 20 credit report. This includes everything numbered in Arabic numerals (excluding front matter) up
% to but excluding the appendices and bibliography.
%
% You must not alter text size (it is currently 10pt) or alter margins or spacing.
%
%
%==================================================================================================================================
%
% IMPORTANT
% The chapter headings here are **suggestions**. You don't have to follow this model if
% it doesn't fit your project. Every project should have an introduction and conclusion,
% however. 
%
%==================================================================================================================================
\chapter{Introduction}

% reset page numbering. Don't remove this!
\pagenumbering{arabic} 

\section{Motivation}

In an era built on rapid technological advancements, there has been a recent explosion of innovative technology proving revolutionary in the monitoring and managing of an individual’s health. Fitness tracking technology has become an increasingly vast market, with a huge increase in people using fitness statistics to ensure they remain active and healthy in their day-to-day lives. However, while physical fitness can be easily measured through distance run or weight lifted, one aspect of fitness often overlooked is your heart health. 

Heart Rate Recovery (HRR) strongly indicates overall cardiovascular health and fitness. However many current fitness tracking applications strongly focus on tracking the physical activity itself through metrics such as distance run and lack HRR readings built in or make it so complex to view these readings that many users will be left unaware they even exist. 

By developing a smartwatch application that prioritises Heart Rate Recovery, I aim to bridge this gap in fitness tracking and bring heart health to the forefront of a user’s fitness tracking experience. This empowers individuals to have a clear and visual representation of their cardiovascular health, with the potential to lead to more effective workouts and a healthier lifestyle.

Furthermore, the convenience of having this application built into a smartwatch means users can view their Heart Rate Recovery at any time without having to use complex equipment or carry their phone about while exercising.

\section{Aim}

This project aims to develop a smartwatch application that allows users to intuitively track their Heart Rate Recovery during a workout, providing them with useful insight into their overall heart health. Results will be represented in visual graphs with a strong focus on the usability heuristics of the application. Within these graphs, there will also be feedback on the users' results, showing ideal values for their Heart Rate Recovery and Heart Rate during a workout. The application will store results in a database to allow users to see their progress and improvements over time, with a HRR comparison feature built in to compare different HRR readings

\section{Outline}

This report will address the issue of Heart Rate Recovery tracking, as well as general Heart Fitness. The breakdown of what each of the sections will expand is as follows:

\begin{itemize}
    \item \textbf{Section 2 - Background Research}
    \begin{itemize}
        \item Looking into related existing applications, as well as investigating the background topics and related work in the field of Heart Fitness and Heart Rate Recovery
    \end{itemize}
    \item \textbf{Section 3 - Requirement Analysis}
    \begin{itemize}
        \item Breaking down the requirements for the finished application, including MoSCoW Requirements and some User Stories
    \end{itemize}
    \item \textbf{Section 4 - Design}
    \begin{itemize}
        \item Delving into the User Interface and the visuals of the application including interaction design, as well as looking more specifically at the System Architecture
    \end{itemize}
    \item \textbf{Section 5 - Implementation}
    \begin{itemize}
        \item Describing the approach to implementing the application, through the hardware configuration, the technologies used, and the algorithms for calculations before finishing with the results overview and graphical representation used
    \end{itemize}
    \item \textbf{Section 6 - Evaluation}
    \begin{itemize}
        \item Explaining the evaluation process for the application, including the auto-ethnography, the pilot study, and finally the conducted experiment through user studies
    \end{itemize}
    \item \textbf{Section 7 - Conclusion}
    \begin{itemize}
        \item Concluding the project and report as a whole, giving a summary of the work accomplished, before delving into the potential future work, and giving a brief final reflection on the project
    \end{itemize}
\end{itemize}


%==================================================================================================================================
\chapter{Background}

\section{Related Applications}

\section{Background Topics}

\section{Related Work}

%==================================================================================================================================
\chapter{Requirement Analysis}

This chapter introduces the requirements the application must tailor to in order to be successful. The requirements were gathered through weekly meetings with my supervisor Dr Sharon Ding. Throughout the project, we maintained an agile approach to the requirements where each meeting the progress and challenges were reviewed and minor adjustments to requirements could be made. The final requirements were then categorised into “Functional” and “Non-Functional” requirements as follows

\section{Functional Requirements}

Functional requirements define the features desired by end users. Prioritisation of these requirements is essential to ensure the development of the application is successful in such a short timeframe. I utilised the MoSCoW requirement prioritisation method (SOURCE), which involves separating the requirements into 4 categories:

\begin{itemize}
    \item Must Have 
    \item Should Have
    \item Could Have
    \item Will Not Have
\end{itemize}

\subsection{Must Have}

"Must Have" requirements specify the essential features for the application's functionality:

\begin{itemize}
    \item \textbf{Heart Rate Tracking} - The application must be able to track a user's heart rate
    \item \textbf{Heart Rate Recovery Calculation} - The application must calculate the user's Heart Rate Recovery
    \item \textbf{Historic HRR Views} - The user must have some way to see their previous Heart Rate Recovery measurements
    \item \textbf{Visual Representation of HRR Readings} - The user must be able to visualise their Heart Rate Recovery
\end{itemize}

\subsection{Should Have}

"Should Have" requirements specify important but not necessary features. These features still however add significant value:

\begin{itemize}
    \item \textbf{Fitness Tracking} - The application should allow for some form of fitness tracking
    \item \textbf{Automatic HRR tracking throughout a workout} - The application should automatically track a user's HRR throughout a workout
    \item \textbf{Feedback on what results mean for a user} - The application should give some form of feedback based on how good a HRR result is
    \item \textbf{HRR Comparisons} - The application should allow for a direct comparison between two HRR measurements to be made 
    
\end{itemize}

\subsection{Could Have}

"Could Have" requirements are features that could slightly add to the overall user experience, but are not massively important:

\begin{itemize}
    \item \textbf{Fitness History} - The application could store historical fitness statistics for the user to review
    \item \textbf{User Profile} - The application could have some form of profile building for a user
\end{itemize}

\subsection{Will Not Have}

"Will Not Have" requirements are features that might improve the overall user experience, but are not a priority for the given time frame:

\begin{itemize}
    \item \textbf{Support a variety of workouts} - In future, the application might host a variety of workouts to track.
    \item \textbf{Colour categorisation for multiple workout types} - In future, the application might have different colour schemes for different workout types.
    \item \textbf{Web Server for storing results} - In future, the application might store information on a web server to allow for viewing results on multiple devices.
    \item \textbf{Mobile App/Mobile-first Web App} - In future, the application might have a mobile/web application developed alongside to allow for additional functionality.
    \item \textbf{Goal Setting for workouts} - In future, the application might have a goal setting functionality, allowing users to set a goal to achieve in their chosen workout. For example, setting that they want to run 5 kilometres before finishing.
\end{itemize}

\section{Non-Functional Requirements}

Non-functional requirements focus on the quality of the finished product, ensuring practicality in the real world. These include:

\textbf{Performance} - The application is being developed on a smartwatch, meaning the performance of the application will be hindered by the smaller computational power in a smartwatch compared to a larger device such as a phone or a computer. It is important to ensure the finished product performs fluently with minimal latency across the system.

\textbf{Portability} -  The application will be used primarily while on the move, such as during an exercise. This means the application needs to be as easy as possible to view and interact with on the move. This is a common design issue when developing applications on a smartwatch (TICWEAR DESIGN SOURCE)

\textbf{Accuracy} - The application is attempting to give an insight into users' health based on their Heart Rate Recovery. If the values presented to the user are inaccurate it could lead to misleading or harmful information for the user

\textbf{Reliability} - It is also important the application is reliable. The previously mentioned “Should Have” category discussed users being able to compare HRR readings. Similar to the reasoning above, if the values over time are vastly different it could lead to harmful interpretations from the user.

%==================================================================================================================================
\chapter{Design}

For some users this could be their first experience using a smartwatch application, therefore it was essential to design the application to be as intuitive as possible. 

There were four main considerations when approaching the user interface that will be discussed further:

\begin{itemize}
    \item \textbf{Application Flow Design} - Exploring the design of user flows throughout the application.
    \item \textbf{User Interface} - Discussing the initial prototyping of the user interface, including how users will interact and navigate through the application.
    \item \textbf{System Architecture} - Exploring the design of the chosen system architecture for the project
    \item \textbf{Database Design} - Explaining the structure, entities and relationships of the database
\end{itemize}

\section{Application Flow Design}

An key aspect to consider when developing the application was how a user would go from opening the application to viewing a HRR reading. The flow of the application was a key factor to understand before starting development. The application has three main flows for the user to take, each accessible from the Home Page seen when the user launches the application as seen below.

The first and main application flow is to record a workout and measure the user’s HRR. This begins with the user selecting the workout they want to do - currently this is just running however, this is where the opportunity for additional workout options would be as discussed in section (ENTER SECTION NUMBER HERE). The application will then enter a multiple-page “Active Workout” display, consisting of two pages that can be swiped between. One page will display the current workout metrics, while the other page acts as a settings page with options to pause or end the workout. Selecting to end the workout then takes the user to another multiple-page “Post-Workout” display. Here the user will be able to see information about their heart rate recovery, heart rate, and more generic workout metrics, as well as being able to return to the home page. This can be visualised in a flow chart, displayed in Figure 4.1 below.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.75\linewidth]{dissertation//dissImages/WorkoutFlow.pdf}
    \caption{Enter Caption}
    \label{fig:enter-label}
\end{figure}

The application also has to allow users to view their previous HRR measurements as defined in the Must Have requirements (ENTER SECTION NUMBER HERE). This is accomplished by clicking the “Health History” button. The app navigates to a multiple-page health history display where all the user’s workouts are shown. Clicking on one of these workouts will then allow you to view the same three pages as the post-workout section in the workout flow, with the possibility for multiple HRRs to be shown. This flow can be seen in Figure 4.2 below.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.75\linewidth]{dissertation//dissImages/HealthHistoryFlow.pdf}
    \caption{Enter Caption}
    \label{fig:enter-label}
\end{figure}

Finally, the application also has a settings flow to allow for database modification. Accessible by clicking the settings icon on the home page, the application navigates to allow a choice between deleting workouts or viewing the set-up profile. If the user selects delete workouts, all workouts stored on the watch are deleted. Otherwise, clicking view profile will display the currently stored user information. This can either be edited - where the user passes through the profile builder described more in section (ENTER SECTION NUMBER HERE) to modify the database - or deleted - deleting the stored user from the database and navigating to set up a new profile. This can be seen in Figure 4.3 below.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.75\linewidth]{dissertation//dissImages/UserSettingFlow.pdf}
    \caption{Enter Caption}
    \label{fig:enter-label}
\end{figure}

\section{User Interface}

When initially approaching the challenge of developing prototype designs, I developed wireframes on Figma. Figma is a very useful tool for developing wireframes quickly by sketching a rough idea of how the application was going to look, with the added ability of creating user interactions. However, it was agreed upon early between me and my supervisor - Dr Sharon Ding - that it would be more beneficial to develop the design directly on the smartwatch itself. This would allow the testing of the user interaction alongside the design to ensure intuitiveness and clarity. It also gave me a more accurate scale to work on when developing the design, rather than developing on a much larger monitor. This also meant the design was one of the key focuses of the evaluation process, discussed further in section (ENTER SECTION NUMBER HERE)

To discuss the final design I’ll break down the application into the three separate flows, discussed earlier in section (ENTER SECTION NUMBER HERE). 

\subsection{Active Workout}

The active workout flow consists of six main pages, being:

\begin{itemize}
    \item \textbf{Select a Workout} - A basic page with buttons allowing the user to select a workout type. Currently this only displays running, however as stated in (ENTER SECTION NUMBER HERE) this is where other workout types would be added.
    \item \textbf{Active Workout} - The page users see while tracking a workout. This page design is discussed further below (ENTER SECTION NUMBER HERE).
    \item \textbf{HRR Measurement in Progress} - A timed page that shows the user their progress during a HRR reading. This is also discussed further in section (ENTER SECTION NUMBER HERE)
    \item \textbf{HRR Measurement} - The page a user sees 60 seconds after ending their workout. It shows the user a graph representation of their Heart Rate Recovery, discussed further in section (ENTER SECTION NUMBER HERE)
    \item \textbf{Heart Rate Range} -  A page showing the user their heart rate across the span of their workout. The graph design and implementation are discussed further in (ENTER SECTION NUMBER HERE)
    \item \textbf{Workout Metrics} - A simple page giving users other information from their workout, such as calories burned, active time and more. It’s also key navigationally for allowing users to return to the home page once their workout is complete.
\end{itemize}

\begin{figure}[h!]
    \centering
    \includegraphics[width=1\linewidth]{dissertation//dissImages/ActiveWorkoutCombined.png}
    \caption{Enter Caption}
    \label{fig:enter-label}
\end{figure}

\subsubsection{Active Workout}

Upon users selecting their workout, they are met with the Active Workout page. The design for this page was a statistic-focused approach, giving the user as much information as possible without over-cluttering the screen. The workout was separated into five sections:

\begin{itemize}
    \item Two timers at the top of the screen that show users their active moving time and total workout duration. These timers were assumed to be intuitive, however caused some confusion at the evaluation stage (ENTER SECTION NUMBER HERE)
    \item The user’s peak heart rate throughout their workout is shown on the left.
    \item An icon in the centre show the user what type of workout they are tracking, in the case of my prototype this is always going to be running
    \item An active calorie tracker on the right shows how many calories the user burned during their workout
    \item The user’s current heart rate, displayed at the bottom of the screen
\end{itemize}

There is also a progress bar surrounding the display, showing a user how close they are to completing a goal they set before the workout such as a target distance or time.

The user can interact with this page through the horizontal pagination of the application, allowing users to swipe along to reveal the workout settings. This workout settings page is a simple page consisting of a play/pause button and an end workout button. The circles seen at the bottom of the design give users a prompt that more content is available than what the initial active workout page shows, according to (ENTER SOURCE HERE). 

\subsection{Health History}

The health history flow also consists of six pages, with two of these being nearly identical to some pages described above:

\begin{itemize}
    \item \textbf{Select a Workout} - This allows users to select a database-stored workout to review. This is set up with a horizontal pagination to show two workouts per page, with circles acting as a page indicator at the bottom to give context to the user of the number of workouts stored. Each workout shows the date the workout was completed below so users can understand what each workout is.
    \item \textbf{HRR Measurement} - The design of this page is identical to the design seen on the active workout page, however has a few navigational differences. This page allows users to view all of their HRR readings recorded during the workout if any more have been taken. The graph also has a “Compare” icon in the top left, where selecting this opens the HRR Select page for users to compare results. This is done to accomplish “HRR Comparisons” discussed as a Should Have requirement in section (ENTER SECTION NUMBER HERE)
    \item \textbf{Heart Rate Range} - This page is entirely identical to the Heart Rate Range page displayed to the user at the end of a workout, described in section (ENTER SECTION NUMBER HERE)
    \item \textbf{Workout Metrics} - Similarly this design is also identical to the page described above, with the only slight navigational difference being the home button navigates to the Select a Workout Page rather than the application home page.
    \item \textbf{HRR Select Compare Page} - This page is designed similarly to the Select a Workout Page, however contains the HRR measurements in the buttons themselves to give users more context on what the measurement they are comparing the result against was like.
    \item \textbf{HRR Compare} - The comparison page shows two different HRR measurements plotted on a graph for easy comparison. The specific design and implementation of the graph are discussed more in section (ENTER SECTION NUMBER HERE). This page uses horizontal pagination once again, allowing users to swipe across to view each of the results individually with the same design as the HRR measurement described in the previous section, finishing with a return to compare button that allows users to return to the  HRR Select Compare Page
\end{itemize}

\begin{figure}[h!]
    \centering
    \includegraphics[width=1\linewidth]{dissertation//dissImages/HealthHistoryCombined.png}
    \caption{Enter Caption}
    \label{fig:enter-label}
\end{figure}

\subsection{User Settings}

The user settings flow contains seven pages, with a few of these pages being very similar in design to one another:

\begin{itemize}
    \item \textbf{User Settings Page} - The landing page when a user enters the user settings flow. It is designed with a simple display of two buttons, one for viewing the profile and one for deleting the workout. The colours are plain here to prevent a user from doing an unintentional and irreversible action, such as a database deletion
    \item \textbf{Profile View Page} - This page displays the stored information about the user: their age, weight and gender. This is displayed as a list at the top of the page to make it easy for users to see if their information is correct.
    \item \textbf{Are You Sure Page} - This page asks the user if they are sure they want to continue with their action, with a simple ‘Yes’ button - with a tick icon - or ‘No’ button - with a cross icon. This layout was chosen to keep consistent with existing technologies, where it is standard to have “confirm” on the right and “cancel” on the left (ENTER SOURCE HERE). There are two different versions of this page with identical designs that pose different questions - one for deleting workouts and one for deleting profiles.
    \item \textbf{Enter Birthday Page} - Here users can enter their birthday to be used for calculating their age at a later stage. Having the user enter their birthday rather than their age directly means the application can automatically update the user’s age rather than requiring them to change it every year. This page is designed with three buttons arranged horizontally, labelled “Day”, “Month” and “Year” respectively. Each of these buttons is associated with a drop-down menu that allows users to select a date. Finally, there is a green button at the bottom with a tick icon, indicating to the user to confirm their choice with this button once they have entered their birthday.
    \item \textbf{Enter Weight Page} - This page allows users to enter their weight. The design is inspired by the Enter Birthday Page to keep consistency across the profile-building process. The page has a button linked to a drop-down menu in the centre of the screen, showing the scale of “kg” next to it. Finally, the same green tick button is at the bottom, allowing users to confirm their selection once they have entered their weight.
    \item \textbf{Select Gender Page} - Here users can select their gender, choosing between “Male”, “Female” or “Other”. The buttons contain the respective icons for each of the genders. When a user selects one of the buttons it inverts the colours, highlighting the selected choice. The consistent design across the profile building is then maintained, with the green tick button in the same position at the bottom of the screen to confirm the choice.
    \item \textbf{Successfully Deleted Page} - A basic splash screen that displays for 2 seconds, showing the user a confirmation message that the deletion was successful - either “Profile Successfully Deleted!” or “Workouts Successfully Deleted!”
\end{itemize}

\begin{figure}[h!]
    \centering
    \includegraphics[width=1\linewidth]{dissertation//dissImages/UserSettingsCombined.png}
    \caption{Enter Caption}
    \label{fig:enter-label}
\end{figure}

\section{System Architecture}

The application is structured around the Model-View-ViewModel (MVVM) architecture, containing three core components:

\begin{itemize}
    \item \textbf{Model} - This layer represents the core data structures, including sensor data gathered. It is also responsible for retrieving and updating data from the database.
    \item \textbf{View} - This layer presents the UI to the user, modified by the ViewModel layer
    \item \textbf{ViewModel} - This serves as an intermediatory layer between the View and the Model, retrieving information from the Model and presenting it to the View to update the UI accordingly. It contains classes that handle data and perform calculations, as well as handling sensor management.
\end{itemize}

\section{Database Design}

The project database has a simple design, with only two entities required for the implementation:

\begin{itemize}
    \item A \textbf{“User”} object - holding all of the information about the user required for calculations discussed in section (ENTER SECTION NUMBER HERE)
    \item A \textbf{“Workout”} object - holding all of the information regarding workout length, date, and heart rate information throughout the workout
\end{itemize}

The relation of these objects does not require foreign keys in the database design. This is because there can only ever be one user object that all workout objects are inherently related to. It was still however important to have unique identifiers for each of the objects, being the primary keys of the entities. For the User object, this identifier is a name field, which is always set to “user” for referencing later. For the Workout object, the identifier is an auto-incrementing ID number.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.75\linewidth]{dissertation//dissImages/ERDiagram.pdf}
    \caption{Enter Caption}
    \label{fig:enter-label}
\end{figure}

%==================================================================================================================================
\chapter{Implementation}

This chapter describes the implementation methods and techniques used throughout the development of the application. It discusses the hardware and software configuration for development, before discussing the algorithms implemented and concluding with the data visualisations displayed to users.

\section{Development Environment}

Development for this project was carried out on the Mobvoi TicWatch Pro 3 GPS, an Android-based smartwatch with the Google Wear OS operating system. The smartwatch includes several sensors accessible through simple API calls built into Android, allowing me to interact freely with the Heart Rate Monitor and Accelerometer as discussed in later sections. 

Application development was carried out on Android 9 “Pie”, corresponding to Wear OS 2.26. Later through the evaluation process, an updated version of Android was tested also ensuring the app remained fully functional on Android 11 “R” with Wear OS 3.5.

The IDE used for the project was Android Studio, the official IDE for Android development built by JetBrains as an extension from IntelliJ. Android Studio has many great features out of the box that ease development, such as the ability to run device emulators to see changes and debug issues quickly without having to download the application to the watch, as well as real-time linting and quick fixes to help spot mistakes or redundancies in code. Another major benefit of developing on Android Studio was the built-in Android Debug Bridge (ADB) - part of the Android Software Development Kit (SDK) - that allows Android Studio to directly connect to the TicWatch over WiFi to send application packages to the watch to be installed.

\section{Technologies}

When deciding on technologies, there were three main areas of concern:

\begin{itemize}
    \item A well-documented and modern programming language to develop the application
    \item A reliable and robust layout framework to make the application as user-friendly as possible
    \item A synchronous and efficient database structure to store data
\end{itemize}

In this section, I will explore the different considerations when selecting the chosen technologies. This includes a brief history of the various technologies, before moving on to the standout features that prompted me to use them and the drawbacks I remained aware of while developing with them

\subsection{Kotlin vs Java}

Historically, Android apps have primarily been developed in Java, the official language of Android Development since Android’s inception in 2008. However, since the release of Kotlin more and more developers have made the change over from Java for feature development.

Kotlin is a statically typed, high-level programming language officially released in 2016 by JetBrains, the company behind the popular Integrated Development Environments (IDEs) IntelliJ and PyCharm (SOURCE). Kotlin was developed with the idea it would become a “better language” than Java ([SOURCE](https://www.jrebel.com/blog)). It remains a younger programming language compared to similar long-term languages such as Java however, was already announced as the preferred programming language for Android development by Google at the Google I/O Conference in 2019.

Kotlin is strongly influenced by Java syntactically while simplifying some of Java’s constructs such as semicolons to end a statement and getter and setter methods. The concise nature of Kotlin - through features such as type inference - allows for around 20\% less code to provide more functionality according to Medium ([SOURCE](https://medium.com/@johnkorly/kotlin-vs-java-performance-drill-down-which-to-choose-2514bdf91916)). Another key benefit of choosing Kotlin is reliability. Due to the nature of static types and null checking in Kotlin, it is reported that Google Home saw a 33\% decrease in NullPointerExceptions after changing over development to Kotlin, with the top 1,000 apps on the Google Play Store having 20\% fewer crashes per user on average ([SOURCE](https://medium.com/androiddevelopers/fewer-crashes-and-more-stability-with-kotlin-b606c6a6ac04)). Ultimately, Kotlin is now the chosen development language by several major international companies such as Netflix, Slack and X due to its benefits over Java however, that doesn’t mean Kotlin doesn’t have its drawbacks.

One of the main difficulties I was wary of was the age of the language. As previously mentioned Kotlin was first stably released in February 2016, just over 20 years after the first Java release in 1996. This immaturity in comparison to Java causes less documentation and general community when trying to solve a problem. In general, when finding a bug in your code you are much more likely to find a solution developing in Java compared to Kotlin. FIND ANOTHER NEGATIVE POINT TO BOOST THIS LAST PARAGRAPH

\subsection{Jetpack Compose vs XML}

Android user interface (UI) development has undergone several changes and improvements over the years. Initially, it was standard to build UIs with XML, a markup language that defines the layout and appearance of UI elements. Using XML allowed developers to separate the layout from the logic of the application and reuse whole components made of XML, similar to many popular modern Web Application frameworks such as React and Flutter. However, XML also had several drawbacks such as its verbosity and inability to support dynamic changing UIs that change for different events. In 2019, Google announced their experiment to solve some of these issues through a project named Jetpack Compose.  It was further refined across two years before reaching its first stable release in July 2021. Since then it has evolved into the recommended way to build Android UI by Google.

Jetpack Compose is a “modern UI toolkit” that aims to simplify the UI development process in Android. It allows for all the functionality of XML and more while maintaining the conciseness of Kotlin programming. In 2020 (CHECK THIS), the TV show tracking Android application ‘Tivi’ went through a migration of an XML-based layout approach to Jetpack Compose and saw a 41\% decrease in Android Package (APK) when using Jetpack Compose. They also report a 76\% decrease in XML lines as well as an 8\% decrease in Kotlin lines across the project while maintaining a very similar application layout. Finally, they also found a 29\% reduction in build time after converting the project to Jetpack Compose. Moving away from statistical improvements, Jetpack Compose also easily allows for dynamic rendering through the use of states. With all the performance improvement and concise nature of Jetpack Compose, alongside the dynamic rendering necessary for my application, Jetpack Compose was the clear choice

However, Jetpack Compose isn’t without its challenges and difficulties. Regardless of the layout framework chosen - XML or Jetpack Compose - they were both new frameworks however, XML is much more similar to previous layout technologies I’ve used such as HTML and CSS. This likely required a slightly longer time to practice and master Jetpack Compose than if I chose to develop in XML. This learning curve is worsened by the lack of documentation and resources available in comparison to XML ([SOURCE](https://medium.com/@gaga.lomidze/xml-vs-jetpack-compose-advantages-and-disadvantages-538ceee28dbd)) due to how new the framework is.

\subsection{Room Database}

Android development has always relied on SQLite - a lightweight and efficient relational database management system - for applications storing data. It is a powerful tool that is well-suited for small to medium-scale projects, known for being reliable and efficient. However, dealing directly with SQLite can be complicated, relying on a lot of boilerplate code to work effectively (SOURCE).

The Room Database is an Android library that simplifies data persistence (SOURCE). It is used as a layer of abstraction over SQLite, maintaining efficiency while reducing the complexity of database interactions. Room is an Object Relational Mapping (ORM) library, meaning it maps database objects directly to Java objects to be interacted with in our code. This greatly reduces the need for boilerplate code when developing a database system. 

Room also has the added benefit of built-in compile-time SQL validation. This means that Room ensures the SQL operations throughout the application are valid, rather than having to debug a crash that would be standard with using an SQLite approach.

Room has three main components:

\begin{itemize}
    \item \textbf{Entity} - An Entity as the name suggests represents an entity in the database. In my application, there are two entities used - a ‘User’ and a ‘Workout’ entity. This is responsible for defining the data types and the structure of the object, allowing for convenient reading and manipulation by Kotlin code when necessary
    \item \textbf{Data Access Object (DAO)} - DAOs are responsible for the interactions with the database. It translates functions called in the Kotlin code into SQL requests, allowing for efficient access to the database whenever it is required
    \item \textbf{Database} - The Database object holds the actual database, and is responsible for instantiating the database upon the launch of the application. It is the main part of the component stack allowing for data persistence, even when the application is closed or the device powers off
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\linewidth]{dissertation//dissImages/RoomDatabaseStructure.png}
    \caption{Enter Caption}
    \label{fig:enter-label}
\end{figure}

\section{Algorithms}

Algorithms are the backbone of functionality within my application, processing and reacting to data to calculate and present detailed results to the user. This chapter will investigate the three algorithms imperative to functionality:

\begin{itemize}
    \item \textbf{Heart Rate Recovery Algorithm} - The core algorithm that, when called upon, stores and calculates the change in a user’s heart rate across a minute. The algorithm stores these heart rates as a list in the database to be used in the results section
    \item \textbf{Automatic Pausing/Automatic HRR Algorithm} - An algorithm essential for the functionality of measuring HRR during a workout. This allows for the detection of a break in the workout, where if this break is greater than a minute in length an extra HRR reading can be taken automatically.
    \item \textbf{Calorific Expenditure Algorithm} - An algorithm used to track the calories burned by the user during a workout. Another useful health metric based on age, weight, gender and heart rate that further helps a user understand how intense their exercise was.
\end{itemize}

These algorithms were implemented in an Android ViewModel as previously discussed in chapter (ENTER CHAPTER HERE) so the calculations can happen in the background and do not prevent the user from using and navigating the application.

There are a few other processes reliant on these algorithms not further explained, one of which is the updating of the progress variable. This progress variable is a measure of the completion percentage of a HRR reading, stored as a floating point number and updated throughout the HRR algorithm. The progress is used during the results section, described in section (ENTER CHAPTER NUMBER HERE), and allows for a progress-bar style update to the user to visualise how far through their HRR reading they are.

The Automatic Pausing functionality described in the automating HRR measurements subsection describes setting the application state to paused or resumed depending on the movement of the device. This application state determines the difference between the Active Time - the time a user is actively moving for - and the Total Duration of a workout - the total time since the workout started. This allows a user to get a more accurate understanding of how long they have been working out.

Finally, the application makes use of theoretical maximum heart rate. This is determined by (SOURCE) as a reliable method to approximate the maximum heart rate of the user, based on their age. It is implemented with the following function:

$$
MaxHR = 211 - (0.64 \times A)
$$

Where $A$ is the user’s age.

\subsection{Heart Rate Recovery}

The main algorithm the application is built around is the Heart Rate Recovery algorithm. This is handled in the form of a function that, when called upon, will track the user’s heart rate over the space of a minute and return the list of results. The reasoning behind returning a list of results is so heart rates can be plotted in a smooth bar chart for the user to help visualise this change in heart rate. This algorithm is run asynchronously to maintain app usability and navigation while these measurements and calculations are happening. 

The algorithm is dependent on the heart rate sensor, another function implemented in the ViewModel. The function registers a listener to the heart rate sensor and then detects any updates from the heart rate sensor. It also keeps track of the peak heart rate that can be used in the HRR calculation, as described in step 1 below. 

To breakdown the algorithm, these are the steps that happen once the function is called:

\begin{enumerate}
    \item All variables are initialised. This includes setting the progress variable to 0 and adding the user’s maximum heart rate to the HRR heart rate list as the beginning heart rate.
    \item Then comes a supposedly infinite while loop with a few break conditions:
    \begin{itemize}
        \item If the loop has been running for greater than or equal to 60 seconds then break from the while loop
        \item If user movement has been detected during a HRR reading then reset all variables changed and break out of the function entirely
    \end{itemize}
    This loop is repeated every 10 milliseconds to update the progress variable smoothly, as discussed in section *ENTER SECTION NUMBER HERE*
    \item During these 60 seconds, heart rate values are added to a new temporary list every 10 milliseconds. Once this list has reached 25 elements in length, the average of these values is added to the bigger HRR heart rate list and the temporary list is reset. This allows for one heart rate to be stored every 250 milliseconds. I found this to be a good balance of capturing variance in the sensor data without overwhelming the database by storing excessive data
    \item After 60 seconds have elapsed the HRR heart rate list holds the values from the reading. The separating value ‘-1’ is added to the list to be used as a separating value, due to the impossibility of -1 ever appearing in the data itself. The peak heart rate is reset to 0 to be used for the next reading.
    \item Finally, the workout object is updated in the database to reflect this new HRR reading. This is done by collecting the most recent workout object, which will always be the current workout, and then appending the gathered data to the end of the list to maintain any previous readings.
\end{enumerate}

When the application requires individual HRR readings, the entire list of heart rates can be collected from the workout object. This list is then split with the -1 separators previously inserted, with each sub-list being a separate HRR reading. The list is passed into the graphing function to display to the user, with the actual HRR value being displayed as the first value stored in the list - being the user’s peak heart rate explained in step 1 - minus the final stored heart rate - being the user’s heart rate after one minute.


\subsection{Automating HRR Measurements}

The algorithm behind automating HRR measurements is an extension of the auto-pausing functionality, dependent on accelerometer data for movement detection. This functionality was implemented in such a way that whenever the user takes a break, the application will automatically detect this and - where the break extends the minute in length required for a HRR reading - will record a HRR reading in the background that can be reviewed at a later stage.

The movement detection algorithm is implemented as follows:

\begin{enumerate}
    \item Whenever the accelerometer sensor is updated - approximately every 10 milliseconds - the magnitude of the acceleration is calculated. This is done with the following formula:

    $$
    \sqrt{x^2 + y^2 + z^2} - 9.81
    $$
    
    Where $x$, $y$ and $z$ represent the three axes of direction. Note the subtraction of 9.81 is to counteract acceleration due to gravity
    \item The magnitude is then added to a measurement list. To keep this list to a standard size, whenever this list exceeds 300 readings, the first reading is removed. Due to the nature of a sensor updates approximately every 10 milliseconds, the measurement list stores approximately a 3-second window of acceleration magnitudes. The average of this list is then calculated, with this value representing the user’s movement across the 3 seconds.
    \item If this average acceleration value drops below the threshold value of 2.75, the application assumes the user to be taking a break. When this happens, the application triggers a vibration to indicate to the user the change in status. 
    \item The application then calculates the theoretical maximum heart rate (POTENTIAL FOR A SOURCE HERE) of the user. Then, ensuring the application is still in a paused state and the current heart rate is greater than half of the theoretical maximum for the user, the application triggers an intermediate HRR reading
\end{enumerate}

Both of the algorithm’s hyperparameters - the threshold value for stopping movement (at 2.75) and the number of readings stored at once from the accelerometer (at 300) - were tuned through the auto-ethnography, with further feedback to optimise the accuracy gathered through the pilot and user studies

\subsection{Calorific Expenditure Algorithm}

The final algorithm explained in detail is the calorific expenditure calculation, used to accumulate the calories burned during a workout. The algorithm heavily relies on the information provided by the user at the profile creation stage, including their weight, age and gender. This calculation is based on (ENTER SOURCE HERE).

The algorithm is implemented as follows:

\begin{enumerate}
    \item Upon a user starts a workout, the function for calculating calories is called. The algorithm acquires the user’s details from the database and calculates the user’s age from their birthday.
    \item Once the algorithm has the user’s details, it enters a while loop with the condition that the state variable calculateCalories is set to true. This state variable is initialised as true and only set to false once a user has finished their workout. Within this while loop, the calories burned across one second are calculated. There are three different calculations the application can use, depending on the gender selected by the user at the time of profile creation:
    \begin{itemize}
        \item Where the user has selected male, the following calculation is used ($H$ = Current Heart Rate, $W$ = User Weight, $A$ = User Age):
        $$
            \frac{-55.0969 + (0.6309 \times H) + (0.1988 \times W) + (0.2017 \times A)}{4.184 \times 60}
        $$
        \item Where the user has selected female, the following calculation is used ($H$ = Current Heart Rate, $W$ = User Weight, $A$ = User Age):
        $$
            \frac{-20.4022 + (0.4472 \times H) + (0.1263 \times W) + (0.074 \times A)}{4.184 \times 60}
        $$
        \item Where the user has selected other, the calculation is determined as the average of the results of the previous two equations. While this solution is not necessarily the most accurate method of measuring calories in this circumstance, according to ([Calculating TDEE/BMR for Transgender or Non-Binary Individuals – ABC Trainerize Help Center](https://help.trainerize.com/hc/en-us/articles/16950447732372-Calculating-TDEE-BMR-for-Transgender-or-Non-Binary-Individuals)) there is “currently no calculation or guideline that does not use sex assigned at birth” to do this calculation, therefore, I believed it to be the best solution to ensure my application caters to as many people as possible.
    \end{itemize}

    \item The result of this calculation is then added to a running total, with this running total being accessible to the frontend of the application to display to the user and store in the database upon workout completion. This while loop is repeated once a second to ensure frequent updates of the current calorie count.
    
\end{enumerate}


\section{Visualising Results}

To present HRR reading results to the user I used a graphical representation, with the main aim of this approach to allow users to visualise complex numbers as a clear and easy-to-understand graph. Tableau (https://www.tableau.com/data-insights/data-visualization/advantages-disadvantages) states that using graphs for data visualisation allows users to more easily comprehend results compared to just showing numbers, leading to a quicker absorption of knowledge.

There are three different categories of graphs implemented within my project, all implemented as bar charts:

\begin{itemize}
    \item \textbf{Heart Rate Recovery} - A representation of the user’s falling heart rate across a minute-long period
    \item \textbf{Heart Rate Range} - A representation of the user’s heart rate throughout their workout, plotted against the duration of their exercise
    \item \textbf{HRR Comparison} - A comparison graph that plots two Heart Rate Recovery measurements, chosen by the user, to display the difference between the two results.
\end{itemize}

The graphs were implemented using the MPAndroidChart library (LINK TO GITHUB HERE). I chose to use this graphing package due to its high level of customisability through a custom renderer. This renderer was implemented slightly differently for each of the graphs mentioned above. In general, it was used to give users more information than just a standard bar chart, where I could highlight target “zones” or differentiate two separate sets of results. MPAndroidChart graphs also have a built-in animation for rendering the bar charts, plotting the results chronologically to further emphasise the progression of readings. 

\subsection{Heart Rate Recovery Graph}

Heart Rate Recovery is the first graph a user sees after they complete a workout. To plot the graph, the first step involves a bucketing process, to normalise the HRR list provided into standardised 30 values. This is a necessary step to maintain the graph styling across the app regardless of the raw values stored in the database. It averages the readings across the graph and gives the user a good overview of how their heart rate varied over the minute-long period. 

To implement this, I first extracted the start and end values from the list, as these were key for calculating the actual heart rate recovery. Heart rate recovery is the peak heart rate minus the heart rate after a minute, therefore we want these exact values not to be impacted by the bucketing process. The rest of the values in the raw list are then processed to fill in the other 28 different values. The bucket size is calculated by dividing the length of the list minus the first and last values by 28, rounding down to the nearest whole number. The remainder is separated across the starting buckets until the index is the size of the remainder. Here is an example of how this works in practice, with a list size of 168 values:

\begin{itemize}
    \item Remove the first and last values of the HRR list for the first and last values in the graph
    \item Divide the remaining 166 by 28 = 5 with remainder of 26
    \item Bucket size of 6 for the first 26 buckets, and 5 for the remaining 2
    \item Take a sublist of the HRR list for the bucket, and add the average as a value to be plotted on the graph
\end{itemize}

Once the list has been normalised to 30 values through the bucketing process, the graph is then plotted. The x-axis shows the progress of time, showing 0s and 60s at the two ends of the measurement. The y-axis shows the heart rate values, allowing users to see the heart rate values throughout the measurement. Above the graph is the actual HRR value, calculated by subtracting the first and last heart rate stored in the HRR list.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\linewidth]{dissertation//dissImages/HRRGraph.png}
    \caption{Enter Caption}
    \label{fig:enter-label}
\end{figure}

As well as the heart rates plotted on the graph, there are also some highlighted zones. These are used in both the Heart Rate Recovery and Heart Rate Range graphs to provide users with more information at a glance on how their readings compare to what is expected. In the case of HRR, there are three different zones:

\begin{itemize}
    \item \textbf{Zone 1 (Low HRR)} - This level indicates a recovery of less than 13 BPM, associated with poor fitness and athletic performance
    \item \textbf{Zone 2 (Healthy HRR)} - This level indicates a recovery between 13 and 25 BPM, associated with an overall average fitness and athletic performance
    \item \textbf{Zone 3 (High HRR)} - This level indicates a recovery greater than 25 BPM, associated with improved fitness and athletic performance
\end{itemize}

These zones are possible thanks to the custom renderer, mentioned in section (ENTER SECTION NUMBER HERE). They are calculated and plotted synchronously with the rest of the graph, coloured semi-transparently to prevent the colours from over-cluttering the graph and confusing users. Users can understand what each of the zones indicates by clicking the information icon, located at the top-right of the graph.

\begin{figure}[h!]
    \centering
    \includegraphics[width=1\linewidth]{dissertation//dissImages/CombinedHRRZones.png}
    \caption{Enter Caption}
    \label{fig:enter-label}
\end{figure}

At the top of the graph, there is also another icon top-left. This icon allows the user into the HRR Comparison page, discussed further in section (ENTER SECTION NUMBER HERE)

\subsection{Heart Rate Range Graph}

When swiping along from the HRR bar chart, you are met with another bar chat showing the Heart Rate of the user across their workout. The implementation of this graph begins in the same way as the HRR bar chart, where the long list of heart rates retrieved from the database is normalised into 30 average values representing the whole workout. This is achieved with an identical bucketing process as described above.

As well as the heart rates, the graph also has a feint grey horizontal line plotted, representing the user’s average heart rate. This value is calculated from the list of heart rates gathered from the database to ensure it takes into account the whole workout. The average heart rate value is displayed above the line as another way for users to understand the intensity of their workout.

The x-axis represents the user’s total workout duration, retrieved from the database, with the different heart rate values being plotted on the y-axis. Above the graph, the heart rate range is shown in the format “{Minimum Heart Rate} - {Maximum Heart Rate} BPM”.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.5\linewidth]{dissertation//dissImages/HRRangeGraph.png}
    \caption{Enter Caption}
    \label{fig:enter-label}
\end{figure}

There are six different highlighted zones representing different levels of heart rate intensity:

\begin{itemize}
    \item \textbf{Zone 1 (Sedentary)} - This level indicates a heart rate less than 50\% of your theoretical maximum heart rate, representing a healthy resting heart rate
    \item \textbf{Zone 2 (Very Light)} - This level represents 50-60\% of your theoretical maximum heart rate, great for improving overall health and helping recovery
    \item \textbf{Zone 3 (Light)} - This level represents 60-70\% of your theoretical maximum heart rate, great for improving basic endurance and fat-burning
    \item \textbf{Zone 4 (Moderate)} - This level represents 70-80\% of your theoretical maximum heart rate, great for improving aerobic fitness
    \item \textbf{Zone 5 (Hard)} - This level represents 80-90\% of your theoretical maximum heart rate, great for increasing maximum performance
    \item \textbf{Zone 6 (Extreme)} - This level represents 90-100\% of your theoretical maximum heart rate, great for developing maximum performance and speed
\end{itemize}

These zones have a different colour scheme to the HRR zones, however maintain a similar semi-transparent approach and are again achievable through the custom renderer. There is an information icon located at the top-right of the graph that allows users to understand what each of the coloured zones represents.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.75\linewidth]{dissertation//dissImages/HRZonesCombined.png}
    \caption{Enter Caption}
    \label{fig:enter-label}
\end{figure}

\subsection{HRR Comparison}

To compare HRR readings previously, users would have to flick between two different readings potentially even in different workouts. It was also often difficult to compare that way due to the different heart rate values in a HRR reading changing the y-axis scale. The HRR comparison page fixes this problem, giving users a simple graph to directly compare two HRR readings from any of their workouts.

Once a user has clicked on the comparison icon, as described at the end of section (ENTER SECTION NUMBER HERE), to compare another measurement to the one their currently on. The user can swipe through all the HRR readings the watch has stored on the database across all their workouts, including the current one. Clicking on another reading then provides the comparison between the selected measurement and the current one through a graph shown below.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.5\linewidth]{dissertation//dissImages/HRRCompareGraph.png}
    \caption{Enter Caption}
    \label{fig:enter-label}
\end{figure}

The plotting of the graph is done almost identically to the HRR bar chart, except for two HRR lists. These two lists are given a separate colour scheme, one red and the other blue, to differentiate between the two plots. By plotting on the same graph, it fixes the issue of scaling while also being able to compare the heart rates across the minute-long interval. Above the graph, the two HRR values are shown, with coloured indicators as the key for the graph. Swiping across also allows users to see the two readings plotted individually if they want to look closer at one of the two measurements.

%==================================================================================================================================
\chapter{Evaluation} 

\section{Auto-Ethnography}

\section{Pilot Study}

\section{User Studies}


%==================================================================================================================================
\chapter{Conclusion}    

\section{Summary}

\section{Future Work}

\section{Final Reflection}

%==================================================================================================================================
%
% 
%==================================================================================================================================
%  APPENDICES  

\begin{appendices}

\chapter{Appendices}

Typical inclusions in the appendices are:

\begin{itemize}
\item
  Copies of ethics approvals (required if obtained)
\item
  Copies of questionnaires etc. used to gather data from subjects.
\item
  Extensive tables or figures that are too bulky to fit in the main body of
  the report, particularly ones that are repetitive and summarised in the body.

\item Outline of the source code (e.g. directory structure), or other architecture documentation like class diagrams.

\item User manuals, and any guides to starting/running the software.

\end{itemize}

\textbf{Don't include your source code in the appendices}. It will be
submitted separately.

\end{appendices}

%==================================================================================================================================
%   BIBLIOGRAPHY   

% The bibliography style is abbrvnat
% The bibliography always appears last, after the appendices.

\bibliographystyle{abbrvnat}

\bibliography{l4proj}

\end{document}
