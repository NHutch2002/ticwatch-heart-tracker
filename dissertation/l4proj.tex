% REMEMBER: You must not plagiarise anything in your report. Be extremely careful.

\documentclass{l4proj}

    
%
% put any additional packages here
%

\begin{document}

%==============================================================================
%% METADATA
\title{Heart Rate Recovery Tracking for Fitness on a Smartwatch}
\author{Nathan Hutchison}
\date{February 2, 2024}

\maketitle

%==============================================================================
%% ABSTRACT
\begin{abstract}
    Every abstract follows a similar pattern. Motivate; set aims; describe work; explain results.
    \vskip 0.5em
    ``XYZ is bad. This project investigated ABC to determine if it was better. 
    ABC used XXX and YYY to implement ZZZ. This is particularly interesting as XXX and YYY have
    never been used together. It was found that  
    ABC was 20\% better than XYZ, though it caused rabies in half of subjects.''
\end{abstract}

%==============================================================================

% EDUCATION REUSE CONSENT FORM
% If you consent to your project being shown to future students for educational purposes
% then insert your name and the date below to  sign the education use form that appears in the front of the document. 
% You must explicitly give consent if you wish to do so.
% If you sign, your project may be included in the Hall of Fame if it scores particularly highly.
%
% Please note that you are under no obligation to sign 
% this declaration, but doing so would help future students.
%
\def\consentname {Nathan Hutchison} % your full name
\def\consentdate {05 February 2024} % the date you agree
%
\educationalconsent


%==============================================================================
\tableofcontents

%==============================================================================
%% Notes on formatting
%==============================================================================
% The first page, abstract and table of contents are numbered using Roman numerals and are not
% included in the page count. 
%
% From now on pages are numbered
% using Arabic numerals. Therefore, immediately after the first call to \chapter we need the call
% \pagenumbering{arabic} and this should be called once only in the document. 
%
% Do not alter the bibliography style.
%
% The first Chapter should then be on page 1. You are allowed 40 pages for a 40 credit project and 30 pages for a 
% 20 credit report. This includes everything numbered in Arabic numerals (excluding front matter) up
% to but excluding the appendices and bibliography.
%
% You must not alter text size (it is currently 10pt) or alter margins or spacing.
%
%
%==================================================================================================================================
%
% IMPORTANT
% The chapter headings here are **suggestions**. You don't have to follow this model if
% it doesn't fit your project. Every project should have an introduction and conclusion,
% however. 
%
%==================================================================================================================================
\chapter{Introduction}

% reset page numbering. Don't remove this!
\pagenumbering{arabic} 

\section{Motivation}

In an era built on rapid technological advancements, there has been a recent explosion of innovative technology proving revolutionary in the monitoring and managing of an individual’s health. Fitness tracking technology has become an increasingly vast market, with a huge increase in people using fitness statistics to ensure they remain active and healthy in their day-to-day lives. However, while physical fitness can be easily measured through distance run or weight lifted, one aspect of fitness often overlooked is your heart health. 

Heart Rate Recovery (HRR) strongly indicates overall cardiovascular health and fitness. However many current fitness tracking applications strongly focus on tracking the physical activity itself through metrics such as distance run and lack HRR readings built in or make it so complex to view these readings that many users will be left unaware they even exist. 

By developing a smartwatch application that prioritises Heart Rate Recovery, I aim to bridge this gap in fitness tracking and bring heart health to the forefront of a user’s fitness tracking experience. This empowers individuals to have a clear and visual representation of their cardiovascular health, with the potential to lead to more effective workouts and a healthier lifestyle.

Furthermore, the convenience of having this application built into a smartwatch means users can view their Heart Rate Recovery at any time without having to use complex equipment or carry their phone about while exercising.

\section{Aim}

This project aims to develop a smartwatch application that allows users to intuitively track their Heart Rate Recovery during a workout, providing them with useful insight into their overall heart health. Results will be represented in visual graphs with a strong focus on the usability heuristics of the application. Within these graphs, there will also be feedback on the users' results, showing ideal values for their Heart Rate Recovery and Heart Rate during a workout. The application will store results in a database to allow users to see their progress and improvements over time, with a HRR comparison feature built in to compare different HRR readings

\section{Outline}

This report will address the issue of Heart Rate Recovery tracking, as well as general Heart Fitness. The breakdown of what each of the sections will expand is as follows:

\begin{itemize}
    \item \textbf{Section 2 - Background Research}
    \begin{itemize}
        \item Looking into related existing applications, as well as investigating the background topics and related work in the field of Heart Fitness and Heart Rate Recovery
    \end{itemize}
    \item \textbf{Section 3 - Requirement Analysis}
    \begin{itemize}
        \item Breaking down the requirements for the finished application, including MoSCoW Requirements and some User Stories
    \end{itemize}
    \item \textbf{Section 4 - Design}
    \begin{itemize}
        \item Delving into the User Interface and the visuals of the application including interaction design, as well as looking more specifically at the System Architecture
    \end{itemize}
    \item \textbf{Section 5 - Implementation}
    \begin{itemize}
        \item Describing the approach to implementing the application, through the hardware configuration, the technologies used, and the algorithms for calculations before finishing with the results overview and graphical representation used
    \end{itemize}
    \item \textbf{Section 6 - Evaluation}
    \begin{itemize}
        \item Explaining the evaluation process for the application, including the auto-ethnography, the pilot study, and finally the conducted experiment through user studies
    \end{itemize}
    \item \textbf{Section 7 - Conclusion}
    \begin{itemize}
        \item Concluding the project and report as a whole, giving a summary of the work accomplished, before delving into the potential future work, and giving a brief final reflection on the project
    \end{itemize}
\end{itemize}


%==================================================================================================================================
\chapter{Background}

\section{Related Applications}

\section{Background Topics}

\section{Related Work}

%==================================================================================================================================
\chapter{Requirement Analysis}

This chapter introduces the requirements the application must tailor to in order to be successful. The requirements were gathered through weekly meetings with my supervisor Dr Sharon Ding. Throughout the project, we maintained an agile approach to the requirements where each meeting the progress and challenges were reviewed and minor adjustments to requirements could be made. The final requirements were then categorised into “Functional” and “Non-Functional” requirements as follows

\section{Functional Requirements}

Functional requirements define the features desired by end users. Prioritisation of these requirements is essential to ensure the development of the application is successful in such a short timeframe. I utilised the MoSCoW requirement prioritisation method (SOURCE), which involves separating the requirements into 4 categories:

\begin{itemize}
    \item Must Have 
    \item Should Have
    \item Could Have
    \item Will Not Have
\end{itemize}

\subsection{Must Have}

"Must Have" requirements specify the essential features for the application's functionality:

\begin{itemize}
    \item \textbf{Heart Rate Tracking} - The application must be able to track a user's heart rate
    \item \textbf{Heart Rate Recovery Calculation} - The application must calculate the user's Heart Rate Recovery
    \item \textbf{Historic HRR Views} - The user must have some way to see their previous Heart Rate Recovery 
    \item \textbf{Visual Representation of HRR Readings} - The user must be able to visualise their Heart Rate Recovery
\end{itemize}

\subsection{Should Have}

"Should Have" requirements specify important but not necessary features. These features still however add significant value:

\begin{itemize}
    \item \textbf{Fitness Tracking} - The application should allow for some form of fitness tracking
    \item \textbf{Automatic HRR tracking throughout a workout} - The application should automatically track a user's HRR throughout a workout
    \item \textbf{Feedback on what results mean for a user} - The application should give some form of feedback based on how good a HRR result is
    \item \textbf{HRR Comparisons} - The application should allow for a direct comparison between two HRR measurements to be made 
    
\end{itemize}

\subsection{Could Have}

"Could Have" requirements are features that could slightly add to the overall user experience, but are not massively important:

\begin{itemize}
    \item \textbf{Fitness History} - The application could store historical fitness statistics for the user to review
    \item \textbf{User Profile} - The application could have some form of profile building for a user
\end{itemize}

\subsection{Will Not Have}

"Will Not Have" requirements are features that might improve the overall user experience, but are not a priority for the given time frame:

\begin{itemize}
    \item \textbf{Support a variety of workouts} - In future, the application might host a variety of workouts to track.
    \item \textbf{Colour categorisation for multiple workout types} - In future, the application might have different colour schemes for different workout types.
    \item \textbf{Web Server for storing results} - In future, the application might store information on a web server to allow for viewing results on multiple devices.
    \item \textbf{Mobile App/Mobile-first Web App} - In future, the application might have a mobile/web application developed alongside to allow for additional functionality.
\end{itemize}

\section{Non-Functional Requirements}

Non-functional requirements focus on the quality of the finished product, ensuring practicality in the real world. These include:

\textbf{Performance} - The application is being developed on a smartwatch, meaning the performance of the application will be hindered by the smaller computational power in a smartwatch compared to a larger device such as a phone or a computer. It is important to ensure the finished product performs fluently with minimal latency across the system.

\textbf{Portability} -  The application will be used primarily while on the move, such as during an exercise. This means the application needs to be as easy as possible to view and interact with on the move. This is a common design issue when developing applications on a smartwatch (TICWEAR DESIGN SOURCE)

\textbf{Accuracy} - The application is attempting to give an insight into users' health based on their Heart Rate Recovery. If the values presented to the user are inaccurate it could lead to misleading or harmful information for the user

\textbf{Reliability} - It is also important the application is reliable. The previously mentioned “Should Have” category discussed users being able to compare HRR readings. Similar to the reasoning above, if the values over time are vastly different it could lead to harmful interpretations from the user.

\section{User Stories}

%==================================================================================================================================
\chapter{Design}

\section{User Interface}

\section{System Architecture}

%==================================================================================================================================
\chapter{Implementation}

\section{Hardware Configuration}

\section{Technologies}

\subsection{Kotlin vs Java}

Historically, Android apps have primarily been developed in Java, the official language of Android Development since Android’s inception in 2008. However, since the release of Kotlin more and more developers have made the change over from Java for feature development.

Kotlin is a statically typed, high-level programming language officially released in 2016 by JetBrains, the company behind the popular Integrated Development Environments (IDEs) IntelliJ and PyCharm (SOURCE). Kotlin was developed with the idea it would become a “better language” than Java ([SOURCE](https://www.jrebel.com/blog)). It remains a younger programming language compared to similar long-term languages such as Java however, was already announced as the preferred programming language for Android development by Google at the Google I/O Conference in 2019.

Kotlin is strongly influenced by Java syntactically while simplifying some of Java’s constructs such as semicolons to end a statement and getter and setter methods. The concise nature of Kotlin - through features such as type inference - allows for around 20\% less code to provide more functionality according to Medium ([SOURCE](https://medium.com/@johnkorly/kotlin-vs-java-performance-drill-down-which-to-choose-2514bdf91916)). Another key benefit of choosing Kotlin is reliability. Due to the nature of static types and null checking in Kotlin, it is reported that Google Home saw a 33\% decrease in NullPointerExceptions after changing over development to Kotlin, with the top 1,000 apps on the Google Play Store having 20\% fewer crashes per user on average ([SOURCE](https://medium.com/androiddevelopers/fewer-crashes-and-more-stability-with-kotlin-b606c6a6ac04)). Ultimately, Kotlin is now the chosen development language by several major international companies such as Netflix, Slack and X due to its benefits over Java however, that doesn’t mean Kotlin doesn’t have its drawbacks.

One of the main difficulties I was wary of was the age of the language. As previously mentioned Kotlin was first stably released in February 2016, just over 20 years after the first Java release in 1996. This immaturity in comparison to Java causes less documentation and general community when trying to solve a problem. In general, when finding a bug in your code you are much more likely to find a solution developing in Java compared to Kotlin. FIND ANOTHER NEGATIVE POINT TO BOOST THIS LAST PARAGRAPH

\subsection{Jetpack Compose vs XML}

Android user interface (UI) development has undergone several changes and improvements over the years. Initially, it was standard to build UIs with XML, a markup language that defines the layout and appearance of UI elements. Using XML allowed developers to separate the layout from the logic of the application and reuse whole components made of XML, similar to many popular modern Web Application frameworks such as React and Flutter. However, XML also had several drawbacks such as its verbosity and inability to support dynamic changing UIs that change for different events. In 2019, Google announced their experiment to solve some of these issues through a project named Jetpack Compose.  It was further refined across two years before reaching its first stable release in July 2021. Since then it has evolved into the recommended way to build Android UI by Google.

Jetpack Compose is a “modern UI toolkit” that aims to simplify the UI development process in Android. It allows for all the functionality of XML and more while maintaining the conciseness of Kotlin programming. In 2020 (CHECK THIS), the TV show tracking Android application ‘Tivi’ went through a migration of an XML-based layout approach to Jetpack Compose and saw a 41\% decrease in Android Package (APK) when using Jetpack Compose. They also report a 76\% decrease in XML lines as well as an 8\% decrease in Kotlin lines across the project while maintaining a very similar application layout. Finally, they also found a 29\% reduction in build time after converting the project to Jetpack Compose. Moving away from statistical improvements, Jetpack Compose also easily allows for dynamic rendering through the use of states. With all the performance improvement and concise nature of Jetpack Compose, alongside the dynamic rendering necessary for my application, Jetpack Compose was the clear choice

However, Jetpack Compose isn’t without its challenges and difficulties. Regardless of the layout framework chosen - XML or Jetpack Compose - they were both new frameworks however, XML is much more similar to previous layout technologies I’ve used such as HTML and CSS. This likely required a slightly longer time to practice and master Jetpack Compose than if I chose to develop in XML. This learning curve is worsened by the lack of documentation and resources available in comparison to XML ([SOURCE](https://medium.com/@gaga.lomidze/xml-vs-jetpack-compose-advantages-and-disadvantages-538ceee28dbd)) due to how new the framework is.

\subsection{Room Database}

\section{Algorithms}

\subsection{Heart Rate Recovery}

\subsection{Auto-Pausing}

\subsection{Calorific Expenditure Algorithm}

\section{Results Overview}

\subsection{Graph Implementation}

\subsection{Heart Rate Recovery Comparison}

%==================================================================================================================================
\chapter{Evaluation} 

\section{Auto-Ethnography}

\section{Pilot Study}

\section{User Studies}


%==================================================================================================================================
\chapter{Conclusion}    

\section{Summary}

\section{Future Work}

\section{Final Reflection}

%==================================================================================================================================
%
% 
%==================================================================================================================================
%  APPENDICES  

\begin{appendices}

\chapter{Appendices}

Typical inclusions in the appendices are:

\begin{itemize}
\item
  Copies of ethics approvals (required if obtained)
\item
  Copies of questionnaires etc. used to gather data from subjects.
\item
  Extensive tables or figures that are too bulky to fit in the main body of
  the report, particularly ones that are repetitive and summarised in the body.

\item Outline of the source code (e.g. directory structure), or other architecture documentation like class diagrams.

\item User manuals, and any guides to starting/running the software.

\end{itemize}

\textbf{Don't include your source code in the appendices}. It will be
submitted separately.

\end{appendices}

%==================================================================================================================================
%   BIBLIOGRAPHY   

% The bibliography style is abbrvnat
% The bibliography always appears last, after the appendices.

\bibliographystyle{abbrvnat}

\bibliography{l4proj}

\end{document}
